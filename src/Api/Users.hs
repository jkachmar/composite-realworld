{-# LANGUAGE Arrows              #-}
{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE FlexibleContexts    #-}
{-# LANGUAGE PatternSynonyms     #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell     #-}
{-# LANGUAGE TypeOperators       #-}

module Api.Users where

import           ClassyPrelude
import           Control.Lens

import           Composite.Record     (pattern (:*:), pattern RNil, Record)
import           Control.Monad.Logger (logError, logInfo)
import           Data.Time            (NominalDiffTime, addUTCTime)
import           Servant              ((:<|>) ((:<|>)), (:>), JSON, Post,
                                       Proxy (Proxy), ReqBody, ServerT, err401,
                                       err404, err500, throwError)
import           Servant.Auth.Server  (Auth, AuthResult (Authenticated),
                                       throwAll)

import           Foundation           (AppStackM, getJWTSettings)
import           Query.User           (insertUser, loginQuery)
import           Types.Auth           (JWTText (JWTText), Token (Token),
                                       makeJWT, unJWTText)
import           Types.BCrypt         (BCrypt (BCrypt), hashPassword, unBCrypt,
                                       validatePassword)
import           Types.User

--------------------------------------------------------------------------------

-- n.b. I don't really know the accepted style to write Servant types ¯\_(ツ)_/¯
-- | Servant type-level representation of the "users" route fragment
type UsersApi auths = (Auth auths Token :> ProtectedApi) :<|> UnprotectedApi

usersApi :: Proxy (UsersApi auths)
usersApi = Proxy

usersServer :: ServerT (UsersApi auths) AppStackM
usersServer = protected :<|> unprotected

--------------------------------------------------------------------------------

-- | Type representation for routes that require authentication.
type ProtectedApi =
       "users"
         :> "register"
           :> ReqBody '[JSON] UserRegisterJson
             :> Post '[JSON] UserResponseJson

-- | Endpoint dispatcher for protected routes, handles authentication.
protected :: AuthResult Token -> ServerT ProtectedApi AppStackM
protected (Authenticated token) = register token
protected _                     = throwAll err401

-- | Registration endpoint, protected by the authentication handlier. for now,
-- any request with a valid token may register users; ideally each class of user
-- would have its own class of token dictating privileges OR each user would
-- have a role in the database that would be used to gate permissions.
register :: Token -> UserRegisterJson -> AppStackM UserResponseJson
register _ (UserRegisterJson userRegister) = do
  hashed    <- hashPassword $ userRegister^.fUserPassword
  maybeUser <- insertUser $ mkUserInsert hashed

  case maybeUser of
    -- If no user was found, throw a 404
    Nothing -> throwError err404

    -- Otherwise, create the JWT and return a User JSON response
    Just user -> do
      token <- mkToken (userRegister^.fUserPassword) user
      jwt   <- mkJWT token 3600
      pure $ mkUserResponse user jwt

  where
    -- Given a hashed password, make a record to be inserted into the database
    -- from the user registration JSON payload
    mkUserInsert :: BCrypt -> Record UserInsert
    mkUserInsert password =
      (   Nothing                  -- User ID, generated by DB
      :*: userRegister^.fUserEmail -- User email
      :*: userRegister^.fUserName  -- User name
      :*: unBCrypt password        -- Textual representation of hashed password
      :*: Nothing                  -- User bio text
      :*: Nothing                  -- User image text
      :*: Nothing                  -- User UUID, generated by DB
      :*: Nothing                  -- User creation timestamp, generated by DB
      :*: Nothing                  -- User update timestamp, generated by DB
      :*: RNil
      )

--------------------------------------------------------------------------------

{-
-- | Type alias for the login response with a secure cookie
type UserResponseCookie = Headers '[ Header "Set-Cookie" SetCookie
                                   , Header "Set-Cookie" SetCookie
                                   ] NoContent
-}

-- | Type representation for routes that do not require authentication.
type UnprotectedApi =
       "users"
         :> "login"
           :> ReqBody '[JSON] UserLoginJson
             :> Post '[JSON] UserResponseJson

-- | Endpoint dispatcher for unprotected routes.
unprotected :: ServerT UnprotectedApi AppStackM
unprotected = login

-- | Login endpoint, unprotected by the authentication handler.
login :: UserLoginJson -> AppStackM UserResponseJson
login (UserLoginJson userLogin) = do

  -- Query the database for a user matching the given email address
  maybeUser <- loginQuery userLogin
  case maybeUser of
    -- If no user was found, throw a 404
    Nothing -> throwError err404

    -- Otherwise, create the JWT and return a User JSON response
    Just user -> do
      token <- mkToken (userLogin^.fUserPassword) user
      jwt   <- mkJWT token 3600
      pure $ mkUserResponse user jwt

--------------------------------------------------------------------------------

-- | Return a token for a given user if the login password is valid when
-- compared to the hash in the database; throw 401 if the user's password
-- is invalid
mkToken :: Text -> Record UserView -> AppStackM Token
mkToken password user = do
  -- Validate the stored hash against the plaintext password
  hashed <- hashPassword password
  $logInfo $ unBCrypt hashed
  $logInfo $ user^.fUserPassword
  isValid <-
    validatePassword
    (BCrypt $ user^.fUserPassword)
    password

  -- If the password isn't valid, throw a 401
  if isValid then pure () else throwError err401
  pure $ Token (user^.fUserUUID)

-- | Return a textual view of a JWT from a token, valid for a given duration
-- of seconds
mkJWT :: Token -> NominalDiffTime -> AppStackM JWTText
mkJWT token duration = do
  -- Try to make a JWT with the settings from the Reader environment, with an
  -- expiry time 1 hour from now
  settings <- asks getJWTSettings
  expires  <- liftBase $ Just . (addUTCTime duration) <$> getCurrentTime
  tryJWT   <- liftBase $ makeJWT token settings expires

  case tryJWT of
    -- If JWT generation failed, log the error and throw a 500
    Left e -> do
      $logError $ "JWT generation failed with the following error [[" <> (tshow e) <> "]]"
      throwError err500

    Right lazyJWT -> pure . JWTText . decodeUtf8 . toStrict $ lazyJWT

mkUserResponse :: Record UserView -> JWTText -> UserResponseJson
mkUserResponse user jwt =
  UserResponseJson
      (   user^.fUserEmail
      :*: unJWTText jwt
      :*: user^.fUserName
      :*: user^.fUserBioMay
      :*: user^.fUserImageMay
      :*: RNil
      )
